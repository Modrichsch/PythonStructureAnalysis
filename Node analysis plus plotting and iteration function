import math
#import matplotlib.pyplot as plt         # Disabled because I don't have the extension, if enabled ignore this message
#from mpl_toolkits import mplot3d       # Disabled because I don't have the extension, if enabled ignore this message
ORnodes = {
    0: (0, 0, 0),
    1: (0.5, 0.5, 0),
    2: (0.5, 0, 0),
    3: (0,0.5,0),
    4: (0.18, 0.8, 0.25),
    5: (1.1, 0.6, 0.25),
    6: (0.7, 0.85, 0.25),
    9: (0.3,0.5,0),
    10: (0.35,0.85,0.25)}

#for comparing to our design before the changes
force_dict = {
    -1: -3,
    6: 1.716,
    7: 0.098,
    8: 0.136,
    9: -0.966,
    10: -1.682,
    11: 2.459,
    12: -1.726,
    13: 1.825,
    14: 3.2,
    15: -2.507,
    16: -1.6, #too high at the moment
    17: -1.152, #slightly too high at the moment
    18: 4.469, #slightly too high at the moment
    19: 5.143, #too low
    20: -1.366,
}

def forces(nodes):
    calc_forces = [0, 0, 0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0, 0,0, 0,0, 0,0, 0,0, -3] #1-20 and the last one "-1" is force F
    angles : tuple = [0]*22 #in sin


    def angler(n1: int, n2: int, m: int):
        dx: float = nodes[n2][0] - nodes[n1][0]
        if dx:
            dy: float = nodes[n2][1] - nodes[n1][1]
            dz: float = nodes[n2][2] - nodes[n1][2]
            x: float = math.sqrt(dx**2 + dz**2)
            angles[m] = math.atan(dy/(x)) #creates the angles

    angler(0, 3, 6)
    angler(0, 9, 7)
    angler(2, 9, 8)
    angler(3, 9, 9)
    angler(9, 1, 10)
    angler(3, 4, 11)
    angler(9, 4, 12)
    angler(9, 10, 13)
    angler(4, 10, 14)
    angler(1, 10, 15)
    angler(1, 6, 16)
    angler(1, 5, 17)
    angler(5, 6, 18)
    angler(10, 6, 19)
    angles.append(0)
    angles[-1] = 0.5*math.pi

    def forceX(mF: int):
        Fx = 0
        for i in range(len(mF)):
            Fx += calc_forces[mF[i]]*math.cos(angles[mF[i]])
        return Fx

    def forceY(mF: int):
        Fy = 0
        for i in range(len(mF)):
            Fy += calc_forces[mF[i]]*math.sin(angles[mF[i]])
        return Fy

    def solve_joint(mForces, newForces, kg):
        if len(newForces) > 2:
            print("too many unknowns!")
            return
        #sum of forces in X
        Fx: float = forceX(mForces)
        #sum of forces in Y
        Fy: float = forceY(mForces)

        #just to make the code "cleaner" will be replaced by a function that computes the angle instead of getting them from the list
        angleX1 = math.cos(angles[newForces[0]])
        angleX2 = math.cos(angles[newForces[1]])
        angleY1 = math.sin(angles[newForces[0]])
        angleY2 = math.sin(angles[newForces[1]])
        angleY = math.sin(angles[newForces[1]]+angles[newForces[0]])

        if not newForces[1]: #only one unknown, easy case
            T1 = -Fx/(angleX1*kg[0])
            return T1
        else:
            #T1 = -Fx - T2*angleX2
            #T1 = -Fy - T2*angleY2
            T2 = (Fx*angleX2-Fy)/(angleY*kg[1])
            print(T2, Fx, Fy, kg[1])
            T1 = (-Fx - T2*angleX2*kg[1])/kg[0]
        
        # sum check
        sum = T1*angleX1 + T2*angleX2 + Fx #should by definition return zero
        calc_forces[newForces[0]] = T1
        calc_forces[newForces[1]] = T2
        return T1, T2

    #sum of forces in joint 5
    solve_joint([-1], [17, 18], [2, 1])
    solve_joint([18], [16, 19], [2, 1])
    return calc_forces

result = forces(ORnodes)
nr = -1
for i in result:
    nr += 1
    print(i, " kN of force for ", nr)
def plot(member:int,boundary_cond:list, change_node: int):#member: which member you would like to see | boundary_cond: limits of movement changenode: which node you would like to move
    nodes = {
    0: (0, 0, 0),
    1: (0.5, 0.5, 0),
    2: (0.5, 0, 0),
    3: (0, 0.5, 0),
    4: (0.18, 0.8, 0.25),
    5: (1.1, 0.6, 0.25),
    6: (0.7, 0.85, 0.25),
    9: (0.3, 0.5, 0),
    10: (0.35, 0.85, 0.25)}
    ax = plt.axes(projection="3d")
    for y in range(boundary_cond[1][0],boundary_cond[1][1],0.001):
        for x in range(boundary_cond[0][0],boundary_cond[0][1],0.001):
            nodes[change_node]=(ORnodes[change_node][0]+x,ORnodes[change_node][1]+y,ORnodes[change_node][2])
            intrested_value=forces[member][2]#the internal force value that we are intrested in
            ax.scatter([0],intrested_value[1],intrested_value[2])
    plt.show()
plot()
