import math
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
ORnodes = {
    0: (0, 0, 0),
    1: (0.5, 0.5, 0),
    2: (0.5, 0, 0),
    3: (0,0.5,0),
    4: (0.18, 0.8, 0.25),
    5: (1.1, 0.6, 0.25),
    6: (0.7, 0.85, 0.25),
    9: (0.3,0.5,0),
    10: (0.35,0.85,0.25)}
def forces(nodes):
    #for comparing to our design before the changes
    force_dict = {
        -1: -3,
        6: 1.716,
        7: 0.098,
        8: 0.136,
        9: -0.966,
        10: -1.682,
        11: 2.459,
        12: -1.726,
        13: 1.825,
        14: 3.2,
        15: -2.507,
        17: -1.152,
        18: 4.469,
        19: 5.143,
        20: -1.366,
    }
    calc_forces = [0, 0, 0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0, 0,0, 0,0, 0,0, 0,0, -3] #1-20 and the last one "-1" is force F

    angles : tuple = [0]*22 #in sin


    def angler(n1, n2, m):
        dx = nodes[n2][0] - nodes[n1][0]
        dy = nodes[n2][1] - nodes[n1][1]
        dz = nodes[n2][2] - nodes[n1][2]
        x = math.sqrt(dx**2 + dz**2)
        angles[m] = math.atan(dy/(x+0.00000000001)) #creates the angles. The 0.0...1 is to prevent division by 0.

    angler(0, 3, 6)
    angler(0, 9, 7)
    angler(2, 9, 8)
    angler(3, 9, 9)
    angler(9, 1, 10)
    angler(3, 4, 11)
    angler(9, 4, 12)
    angler(9, 10, 13)
    angler(4, 10, 14)
    angler(1, 10, 15)
    angler(1, 6, 16)
    angler(1, 5, 17)
    angler(5, 6, 18)
    angler(10, 6, 19)
    angles.append(0)
    angles[-1] = 0.5*math.pi

    def forceX(mF):
        Fx = 0
        for i in range(len(mF)):
            Fx += calc_forces[mF[i]]*math.cos(angles[mF[i]])
        return Fx

    def forceY(mF):
        Fy = 0
        for i in range(len(mF)):
            Fy += calc_forces[mF[i]]*math.sin(angles[mF[i]])
        return Fy

    def solve_joint(mForces, newForces, kg):
        if len(newForces) > 2:
            print("too many unknowns!")
            return
        #sum of forces in X
        Fx = forceX(mForces)
        #sum of forces in Y
        Fy = forceY(mForces)

        #just to make the code "cleaner" will be replaced by a function that computes the angle instead of getting them from the list
        angleX1 = math.cos(angles[newForces[0]])
        angleY1 = math.cos(angles[newForces[1]])
        angleX2 = math.sin(angles[newForces[0]])
        angleY2 = math.sin(angles[newForces[1]])

        if not newForces[1]: #only one unknown, easy case
            T1 = -Fx/(angleX1*kg[0])
            return T1
        elif angleX1: #whether unknown force 1 has an x component
            if not angleX2: #Whether unknown force 2 has an x component
                T1 = -Fx / (angleX1*kg[0])
                T2 = -Fy - T1*angleY1*kg[0]
            elif angleY1: #both forces have an x component and the y sum is needed (most common and elaborate case)
                if angleY2:
                    #T1 = -Fx - T2*angleX2
                    #T1 = -Fy - T2*angleY2
                    T2 = (Fx-Fy)/(angleY2 - angleX2) / kg[1]
                    T1 = (-Fx - T2*angleX2*kg[1])/kg[0]
                else:
                    T1 = -Fy/angleY1
                    T2 = -Fx - T1*angleX1
            else:
                T2 = -Fy/angleY2
                T1 = -Fx - T2*angleX2
        else:
            T2 = -Fx/angleX2
        # sum check
        sum = T1*angleX1 + T2*angleX2 + Fx #should by definition always return 0.  I tested it, it gave -0.115 != 0
        print(sum, " = sum of forces with Fx =", Fx)
        calc_forces[newForces[0]] = T1
        calc_forces[newForces[1]] = T2
        return T1, T2

    #sum of forces in joint 5
    solve_joint([-1], [17, 18], [2, 1])
    solve_joint([18], [16, 19], [2, 1])
    solve_joint([17, 20], [16, 19], [2, 1])
    for i in range(20):
        print(i, calc_forces[i])
    return calc_forces
def plot(node,boundary_cond, changenode):#node:which node ypu would like to see boundary_cond: limits of movement changenode: which node you would like to move
    nodes = {
        0: (0, 0, 0),
        1: (0.5, 0.5, 0),
        2: (0.5, 0, 0),
        3: (0, 0.5, 0),
        4: (0.18, 0.8, 0.25),
        5: (1.1, 0.6, 0.25),
        6: (0.7, 0.85, 0.25),
        9: (0.3, 0.5, 0),
        10: (0.35, 0.85, 0.25)}
    for y in range(boundary_cond[1][0],boundary_cond[1][1],0.001):
        for x in range(boundary_cond[0][0],boundary_cond[0][1],0.001):
            nodes[changenode]=(ORnodes[changenode][0]+x,ORnodes[changenode][1]+y,ORnodes[changenode][2])
            intrested_value=forces(node)[node]
            ax=plt.axes(projection="3d")
            ax.scatter([0],intrested_value[1],intrested_value[2])
    plt.show()
